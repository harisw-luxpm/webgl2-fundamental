<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="c"></canvas>
</body>
<script src="https://webgl2fundamentals.org/webgl/resources/twgl-full.min.js"></script>
<script src="https://webgl2fundamentals.org/webgl/resources/m4.js"></script>
<script src="https://webgl2fundamentals.org/webgl/resources/flattened-primitives.js"></script>
<script type="text/javascript">

    var vertexShaderSource = `#version 300 es
    //input attribute (in) to vertexshader to receive data from buffer
    in vec4 a_position;   //to use clip space
    in vec4 a_color;

    uniform mat4 u_matrix;
    
    out vec4 v_color;
    void main() {
        gl_Position = u_matrix * a_position;

        v_color = a_color;
    }`;

    var fragmentShaderSource = `#version 300 es
    //highp good default precision for high precision
    precision highp float;
    //passed in from vertex shader
    in vec4 v_color;
    uniform vec4 u_colorMult;
    out vec4 outColor;

    void main() {
        outColor = v_color * u_colorMult;
    }
    `;

    function createShader(gl, type, source) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        
        if (success) return shader;
        
        console.log(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    }
    function createProgram(gl, vertexShader, fragmentShader) {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        var success = gl.getProgramParameter(program, gl.LINK_STATUS);
        
        if (success) return program;

        console.log(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
    }

    function main() {
        var canvas = document.querySelector('#c');
        var gl = canvas.getContext('webgl2');
        if(!gl) {
            console.log('No webgl here');
            return;
        }
        twgl.setAttributePrefix("a_");

        var sphereBufferInfo = flattenedPrimitives.createSphereBufferInfo(gl, 10, 12, 6);
        var cubeBufferInfo = flattenedPrimitives.createCubeBufferInfo(gl, 20);
        var coneBufferInfo = flattenedPrimitives.createTruncatedConeBufferInfo(gl, 10, 0, 20, 12, 1, true, false);

        //setup GLSL program
        var programInfo = twgl.createProgramInfo(gl, [vertexShaderSource, fragmentShaderSource]);

        var sphereVAO = twgl.createVAOFromBufferInfo(gl, programInfo, sphereBufferInfo);
        var cubeVAO = twgl.createVAOFromBufferInfo(gl, programInfo, cubeBufferInfo);
        var coneVAO = twgl.createVAOFromBufferInfo(gl, programInfo, coneBufferInfo);

        function degToRad(d) {
            return d* Math.PI / 180;
        }

        var fieldOfViewRadians = degToRad(60);

        //uniforms for each obj
        var sphereUniforms = {
            u_colorMult: [0.5, 1, 0.5, 1],
            u_matrix: m4.identity()
        };
        var cubeUniforms = {
            u_colorMult: [1, 0.5, 0.5, 1],
            u_matrix: m4.identity
        };
        var coneUniforms = {
            u_colorMult: [0.5, 0.5, 1, 1],
            u_matrix: m4.identity()
        };
        var sphereTranslation = [ 0, 0, 0];
        var cubeTranslation = [-40, 0, 0];
        var coneTranslation = [40, 0, 0];

        function computeMatrix(viewProjectionMatrix, translation, xRotation, yRotation) {
            var matrix = m4.translate(viewProjectionMatrix,
                translation[0],
                translation[1],
                translation[2]);
            matrix = m4.xRotate(matrix, xRotation);
            return m4.yRotate(matrix, yRotation);
        }

        requestAnimationFrame(drawScene);

        function drawScene(time) {
            time = time * 0.0005;

            twgl.resizeCanvasToDisplaySize(gl.canvas);

            //tell webgl how to convert clip space to pixels
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.enable(gl.CULL_FACE);
            gl.enable(gl.DEPTH_TEST);

            //compute projection matrix
            var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            var projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

            //compute camera's matrix using look at
            var cameraPosition = [0, 0, 100];
            var target = [0, 0, 0];
            var up = [0, 1, 0];
            var cameraMatrix = m4.lookAt(cameraPosition, target, up);

            //make view matrix from camera
            var viewMatrix = m4.inverse(cameraMatrix);

            var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

            var sphereXRotation =  time;
            var sphereYRotation =  time;
            var cubeXRotation   = -time;
            var cubeYRotation   =  time;
            var coneXRotation   =  time;
            var coneYRotation   = -time;

            gl.useProgram(programInfo.program);

            // Draw the sphere
            gl.bindVertexArray(sphereVAO);
            sphereUniforms.u_matrix = computeMatrix(
                viewProjectionMatrix,
                sphereTranslation,
                sphereXRotation,
                sphereYRotation,
            );

            twgl.setUniforms(programInfo, sphereUniforms);
            twgl.drawBufferInfo(gl, sphereBufferInfo);

            //draw cube
            gl.bindVertexArray(cubeVAO);
            cubeUniforms.u_matrix = computeMatrix(
                viewProjectionMatrix,
                cubeTranslation,
                cubeXRotation,
                cubeYRotation,
            );

            twgl.setUniforms(programInfo, cubeUniforms);
            twgl.drawBufferInfo(gl, cubeBufferInfo);

            //draw Cone
            gl.bindVertexArray(coneVAO);
            coneUniforms.u_matrix = computeMatrix(
                viewProjectionMatrix,
                coneTranslation,
                coneXRotation,
                coneYRotation
            );

            //set computed uniforms
            twgl.setUniforms(programInfo, coneUniforms);
            twgl.drawBufferInfo(gl, coneBufferInfo);

            requestAnimationFrame(drawScene);
        }

    }

    main();
</script>
</html>